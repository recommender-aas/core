package gr.ml.analytics.service

import java.util.concurrent.atomic.AtomicInteger

import com.typesafe.scalalogging.LazyLogging
import gr.ml.analytics.cassandra.{CassandraStorage, Schema}
import org.json4s.{DefaultFormats, Formats}

import scala.concurrent.Future

class SchemaServiceImpl(inputDatabase: CassandraStorage) extends SchemaService with LazyLogging {

  private lazy val schemasModel = inputDatabase.schemasModel

  private val idCounter: AtomicInteger = new AtomicInteger(0)

  implicit val jsonFormats: Formats = DefaultFormats

  override def get(id: Int): Future[Option[Schema]] = {
    schemasModel.getOne(id)
  }

  override def save(jsonSchema: Map[String, Any]): Int = {

    val normalizedStringSchema = Util.schemaToString(jsonSchema)

    logger.info(s"Saving $normalizedStringSchema")

    // TODO should be generated by Cassandra
    val schemaId = idCounter.getAndIncrement()

    schemasModel.save(Schema(schemaId, jsonSchema))

    val tableName = Util.itemsTableName(schemaId)
    val tableNameDense = Util.itemsTableName(schemaId) + "_dense"

    // create cassandra table for items
    val (pkColumnName, pkColumnType) = Util.extractIdMetadata(jsonSchema)
    val featureColumnsInfo: List[Map[String, String]] = Util.extractFeaturesMetadata(jsonSchema)

    val columnsString: String = featureColumnsInfo
      .map(feature => (feature("name"), feature("type")))
      .foldLeft("") { (s: String, pair: (String, String)) =>
        s + " ," + pair._1 + " " + pair._2
      }

    val q = s"CREATE TABLE ${schemasModel.keySpace}.$tableName ($pkColumnName $pkColumnType PRIMARY KEY $columnsString )"
    logger.info(s"Creating: $q")
    schemasModel.session.execute(q).getColumnDefinitions

    val q2 = s"CREATE TABLE ${schemasModel.keySpace}.$tableNameDense (itemid $pkColumnType PRIMARY KEY, features list<double> )" // TODO unhardcode!
    logger.info(s"Creating: $q2")
    schemasModel.session.execute(q2).getColumnDefinitions

    schemaId
  }
}
